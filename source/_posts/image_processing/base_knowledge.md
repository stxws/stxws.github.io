---
title: '数字图像基础'
date: 2020-02-18 20:44:55
categories: 图像处理
tags: [图像处理]
mathjax: true
---
一些关于数字图像处理的基本知识
<!-- more -->


# 基本概念
**单色光**：没有颜色的光，单色光的唯一属性是强度。
**灰度级**：单色光的强度，从黑到白的单色光的度量值范围。
**灰度图像**：用单色光来表示的图像。

一幅图像可以用一个矩阵来表示，矩阵中某个元素表示图像在该点的像素，可以是灰度值或RGB值等。
**空间域**：一幅数字图像的坐标张成的实平面部分。
**像素**：图像矩阵中的元素，也可以称之为图像单元或图像元素。

**噪声**：存在于图像数据中的不必要的或多余的干扰信息。
**对比度**：图像中最高和最低灰度级间的灰度差。
**饱和度**：指图像色彩的纯净程度。

**空间分辨率**：用来度量图像中可辨别的最小细节，，通常用单位距离的线对数或单位距离的点数（像素数）来衡量。
**dpi**：每英寸点数，通常作为单位距离点数的单位。
**灰度分辨率**：指灰度级中可分辨的最小变化，用于量化灰度的比特数。例如，通常说一幅被量化为256级的图像有8比特的灰度分辨率。


# 像素间的基本关系
## 相邻像素
&emsp;&emsp;**4邻域**：与像素相邻的四个水平和垂直的相邻像素，坐标为$(x,y)$的像素的4邻域坐标为$(x+1,y)、(x-1,y)、(x,y+1)、(x,y-1)$，像素点p的4邻域可以用$N_4(p)$表示。
&emsp;&emsp;**D邻域**：与像素相邻的四个对角相邻像素，坐标为$(x,y)$的像素的D邻域坐标为$(x-1,y-1)、(x-1,y+1)、(x+1,y-1)、(x+1,y+1)$，像素点p的4邻域可以用$N_D(p)$表示。
&emsp;&emsp;**8邻域**：由像素的4邻域和D邻域组成。像素点p的8邻域可以用$N_8(p)$表示。
&emsp;&emsp;位于图像边界的像素点的4邻域、D邻域和8邻域会落入图像的外部。

## 邻接性
&emsp;&emsp;令$V$是定义邻接的灰度值集合，假设像素$p$和$q$的像素值在集合$V$中，像素$p$和$q$的4邻接、8邻接和m邻接定义如下
&emsp;&emsp;**4邻接**：如果$q$在$p$的4邻域中，则$p$和$q$是4邻接的。
&emsp;&emsp;**8邻接**：如果$q$在$p$的8邻域中，则$p$和$q$是8邻接的。
&emsp;&emsp;**m邻接**：如果像素$p$和$q$满足以下两个条件之一，则$p$和$q$是m邻接的。
&emsp;&emsp;&emsp;&emsp; 1. $q$在$p$的4邻域中。
&emsp;&emsp;&emsp;&emsp; 2. $q$在$p$的D邻域中，且$p$和$q$的4邻域交集中没有没有来自$V$中数值的像素。
&emsp;&emsp;m邻接也叫混合邻接，m邻接是8邻接的改进，目的是消除8邻接带来的对角相邻像素之间可能产生的多余的斜向路径。

## 连通性
&emsp;&emsp;**通路**：像素$p$到像素$q$之间的通路是由不同像素组成的一个序列，序列中左右相邻的两个像素之间都是邻接的。可根据不同的邻接类型（4邻接、8邻接、m邻接）定义不同的通路类型（4通路、8通路、m通路），其中8通路可能不唯一。
&emsp;&emsp;**连通**：令$S$是图像中的一个像素子集（图像中像素点组成的集合）。如果两个像素$p$和$q$之间存在一条完全由$S$中的像素构成的通路（像素$p$和$q$均在$S$中），那么称像素$p$和$q$在$S$中连通。
&emsp;&emsp;**连通分量**：对于$S$中的任意一个像素$p$，在$S$中与像素$p$连通的像素构成的像素集合称为$S$的连通分量。
&emsp;&emsp;**连通集**：如果$S$仅有一个连通分量，即$S$中的所有像素互相都连通，则$S$称为连通集。

## 区域和边界
&emsp;&emsp;**区域**：令$R$是图像中的一个像素子集，如果$R$是一个连通集，则称$R$为图像的一个区域。
&emsp;&emsp;**邻接区域**：两个区域$R_i$和$R_j$，如果将他们合并后能够形成一个连通集，则称区域$R_i$和$R_j$为邻接区域。不邻接的区域称为不邻接区域。
&emsp;&emsp;**边界**：区域$R$的边界（也叫边框或者轮廓）是区域$R$中与$R$的补集邻接的像素点组成的集合。
&emsp;&emsp;假设一幅图像中含有$K$个不邻接的区域$R_k,k=1,2,...,K$，且这些区域都不接触图像的边界。令$Ru$表示这$K$个区域的并集，$(Ru)c$表示$Ru$的补集，那么$Ru$称中的所有像素点为图像的前景，$(Ru)c$中的所有像素点为图像的背景。
&emsp;&emsp;上述边界的定义有时称为区域的**内边界**，即边界像素是在区域内部。与内边界相区分的是**外边界**，即边界像素在背景区域内。

## 距离度量
&emsp;&emsp;设像素点$p$的坐标为$(x_p,y_p)$，$q$的坐标为$(x_q,y_q)$，则$p$和$q$之间的三种距离定义如下。
&emsp;&emsp;**欧式距离**：用$D_e(p,q)$来表示。
$$D_e(p,q) = \sqrt{(x_p - x_q)^2 + (y_p - y_q)^2}$$

&emsp;&emsp;在欧式距离度量下，到像素点$(x,y)$的距离小于等于某一特定值$r$的像素都在以$(x,y)$为中心、半径为$r$的圆形区域内。

&emsp;&emsp;**城市距离**：用$D_4(p,q)$来表示。
$$D_4(p,q) = |x_p - x_q| + |y_p - y_q|$$

&emsp;&emsp;在城市距离度量下，到像素点$(x,y)$的距离小于等于某一特定值$r$的像素形成一个以$(x,y)$为中心的菱形区域。

&emsp;&emsp;**棋盘距离**：用$D_8(p,q)$来表示。
$$D_8(p,q) = max(|x_p - x_q|,|y_p - y_q|)$$

&emsp;&emsp;在棋盘距离度量下，到像素点$(x,y)$的距离小于等于某一特定值$r$的像素形成一个以$(x,y)$为中心的方形区域。


# 数学基础
## 阵列与矩阵操作
&emsp;&emsp;**阵列操作**：对图像矩阵中每个像素进行操作，比如对图像阵列进行求幂操作，表示对图像矩阵中每个像素都进行求幂。
&emsp;&emsp;**矩阵操作**：对图像矩阵进行矩阵的操作，矩阵的操作请参考线性代数里的介绍。
&emsp;&emsp;矩阵操作的乘法和阵列操作的乘法不同。
&emsp;&emsp;阵列操作的乘法：
$$
\left[\begin{matrix}
	a_{11} & a_{12} \\\\
	a_{21} & a_{22} \\\\
\end{matrix}\right]
\left[\begin{matrix}
	b_{11} & b_{12} \\\\
	b_{21} & b_{22} \\\\
\end{matrix}\right] = 
\left[\begin{matrix}
	a_{11}b_{11} & a_{12}b_{12} \\\\
	a_{21}b_{21} & a_{22}b_{22} \\\\
\end{matrix}\right]
$$

&emsp;&emsp;矩阵操作的乘法：
$$
\left[\begin{matrix}
	a_{11} & a_{12} \\\\
	a_{21} & a_{22} \\\\
\end{matrix}\right]
\left[\begin{matrix}
	b_{11} & b_{12} \\\\
	b_{21} & b_{22} \\\\
\end{matrix}\right] = 
\left[\begin{matrix}
	a_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\
	a_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\\\
\end{matrix}\right]
$$

## 线性操作
&emsp;&emsp;图像处理方法最重要的分类依据之一是，它是线性的还是非线性的。考虑一般的算子$H$，该算子对于给定的输入图像$f(x,y)$，产生一幅输出图像$g(x,y)$：
$$H[f(x, y)] = g(x, y)$$

&emsp;&emsp;**加性**：对两个输入的和进行操作得到的输出，与分别对两个输入进行操作后的输出求和得到的结果相同，用公式可表示为：
$$H[f_i(x, y) + f_j(x, y)] = H[f_i(x, y)] + H[f_i(x, y)]$$

&emsp;&emsp;**同质性**：输入乘以一个常数的输出，与原始输入的输出再乘以该常数的结果相同，用公式可表示为：
$$H[a \times f(x, y)] = a \times H[f(x, y)]$$

&emsp;&emsp;**线性操作**：同时满足加性和同质性的操作，线性操作的算子成为线性算子，如果$H$是一个线性算子，则需要满足：
$$H[a_if_i(x, y) + a_jf_j(x, y)] = a_iH[f_i(x, y)] + a_jH[f_j(x, y)] = a_ig_i(x, y) + a_jg_j(x, y)$$

&emsp;&emsp;上式中，$a_i$和$a_j$是任意常数，$f_i(x, y)$和$f_j(x, y)$是任意大小相同的图像。

## 算术操作
&emsp;&emsp;图像间的算术操作是在相应的像素对之间执行的，属于阵列操作，4种算术操作（即像素间加减乘除）表示为：
$$
s(x, y) = f(x, y) + g(x, y) \\\\
d(x, y) = f(x, y) - g(x, y) \\\\
p(x, y) = f(x, y) \times g(x, y) \\\\
v(x, y) = f(x, y) \div g(x, y)
$$

&emsp;&emsp;上式中$f$和$g$是两张大小相同的图像，计算得到的$s$、$d$、$p$和$v$也是和$f$、$g$大小相同的图像。
&emsp;&emsp;**图像相加**后取平均值可以降低图像的噪声。在天文学邻域，由于在非常低的光照下成像常常会导致传感器噪声，以至于单幅图像无法分析。一种降低噪声的方法是对同一个区域（比如某个星系）进行长时间观测，采集多张图片，然后将这多张图像进行算术相加再取平均值，最后得到的图像相比于单张图像会清晰很多。
&emsp;&emsp;**图像相减**可以增强两幅近似图像之间的差别，比如观测某一区域的变化过程，可以用采集的图像与第一次采集的图像相减，以增强两幅图像变化比较明显的部分，降低变化比较小的部分。
&emsp;&emsp;**图像相乘**的一个重要应用是矫正阴影（这个没看懂T﹏T）。也用来进行模板操作。

## 空间操作
&emsp;&emsp;空间操作直接在给定图像的像素上执行。
### 单像素操作
&emsp;&emsp;单像素操作生成的图像，每个像素是根据原图中相应像素计算得到的。用公式表示是：
$$g(x, y) = T[f(x, y)]$$

&emsp;&emsp;$f(x, y)$表示原图在$(x, y)$处的像素，$T$表示像素的映射函数，$g(x, y)$表示生产图像对应位置的像素。
### 领域操作
&emsp;&emsp;领域操作生成的图像，每个像素是根据原图中相应像素的领域计算得到的。用公式表示是：
$$g(x, y) = T[N(f(x, y))]$$

&emsp;&emsp;$N(f(x, y))$表示图像在$(x, y)$处的领域。
### 几何空间变换
&emsp;&emsp;请参考我的另一篇博客[图像的几何空间变换](/image_processing/space_transformation/)。
### 图像配准
&emsp;&emsp;图像几何空间变换利用已知的变换函数，将原图像上的像素映射到目标图像上指定的位置。而图像的配准则是根据原图像和目标图像上某些像素点之间的映射关系，求变换函数。具体的做法是假设变换函数的模型，然后在原图像上取一些点，将这些点的坐标和它们映射在目标图像上对应点的坐标，代入变换函数模型中，求解出变换函数的未知参数，最终得到变换函数。
&emsp;&emsp;举个栗子，假设目标图像是原图像通过仿射变换生成的，变换方式如下：
$$
\left[\begin{matrix} x & y & 1 \end{matrix}\right] = 
\left[\begin{matrix} v & w & 1 \end{matrix}\right]T = 
\left[\begin{matrix} v & w & 1 \end{matrix}\right]
\left[\begin{matrix}
t_{11} & t_{12} & 0 \\\\
t_{21} & t_{22} & 0 \\\\
t_{31} & t_{32} & 1
\end{matrix}\right]
$$

&emsp;&emsp;根据这个变换函数可以列出以下两个方程，这个两个方程就是变换函数的模型。
$$
x = t_{11}v + t_{21}w + t_{31} \\\\
y = t_{12}v + t_{22}w + t_{32}
$$

&emsp;&emsp;然后取原图像上的三个点$(v_1, w_1)$、$(v_2, w_2)$、$(v_3, w_3)$，假设它们在目标图像上对应点的坐标分别是$(x_1, y_1)$、$(x_2, y_2)$、$(x_3, y_3)$，将这六个点的坐标值代入变换函数模型中，可以的到两个三元一次方程组：
$$
\begin{cases}
	x_1 = t_{11}v_1 + t_{21}w_1 + t_{31} \\\\
	x_2 = t_{11}v_2 + t_{21}w_2 + t_{31} \\\\
	x_3 = t_{11}v_3 + t_{21}w_3 + t_{31}
\end{cases} \ \ \ \ \ \ \ 
\begin{cases}
	y_1 = t_{12}v_1 + t_{22}w_1 + t_{32} \\\\
	y_2 = t_{12}v_2 + t_{22}w_2 + t_{32} \\\\
	y_3 = t_{12}v_3 + t_{22}w_3 + t_{32}
\end{cases}
$$

&emsp;&emsp;解出这两个方程组就可以算出$t_{11}、t_{12}、t_{21}、t_{22}、t_{31}、t_{32}$这几个参数，代入模型中就是我们要求的变换函数了。
